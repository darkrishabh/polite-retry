<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Guide - Polite Retry</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
  <nav class="navbar">
    <div class="nav-container">
      <a href="index.html" class="nav-logo">
        <span class="logo-icon">ü§ù</span>
        <span>Polite Retry</span>
      </a>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <a href="guide.html" class="active">Guide</a>
        <a href="api.html">API</a>
        <a href="examples.html">Examples</a>
        <a href="https://github.com/darkrishabh/polite-retry" class="github-link" target="_blank">
          <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
          </svg>
          GitHub
        </a>
      </div>
    </div>
  </nav>

  <main class="container">
    <div class="docs-layout">
      <aside class="sidebar">
        <nav class="sidebar-nav">
          <h4>Getting Started</h4>
          <ul>
            <li><a href="#installation">Installation</a></li>
            <li><a href="#quick-start">Quick Start</a></li>
            <li><a href="#core-concepts">Core Concepts</a></li>
          </ul>
          <h4>Retry Strategies</h4>
          <ul>
            <li><a href="#basic-retry">Basic Retry</a></li>
            <li><a href="#circuit-breaker">Circuit Breaker</a></li>
            <li><a href="#adaptive-budget">Adaptive Budget</a></li>
            <li><a href="#combined">Combined Protection</a></li>
          </ul>
          <h4>Advanced Topics</h4>
          <ul>
            <li><a href="#backoff">Backoff Strategies</a></li>
            <li><a href="#jitter">Jitter Explained</a></li>
            <li><a href="#backpressure">Backpressure</a></li>
            <li><a href="#metrics">Metrics</a></li>
          </ul>
          <h4>Best Practices</h4>
          <ul>
            <li><a href="#dos-donts">Dos and Don'ts</a></li>
            <li><a href="#production">Production Tips</a></li>
          </ul>
        </nav>
      </aside>

      <div class="guide-content">
        <h1>Getting Started Guide</h1>
        <p>This guide will walk you through using Polite Retry to build resilient distributed systems.</p>

        <h2 id="installation">Installation</h2>
        <div class="code-example">
          <pre><code class="language-bash">npm install polite-retry</code></pre>
        </div>

        <h2 id="quick-start">Quick Start</h2>
        <p>The simplest way to use Polite Retry is with the <code>retry()</code> function:</p>
        <div class="code-example">
          <pre><code class="language-typescript">import { retry } from 'polite-retry';

const data = await retry(
  async () => {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return response.json();
  },
  {
    maxRetries: 3,
    initialDelayMs: 100,
    jitter: 'full',
  }
);</code></pre>
        </div>

        <h2 id="core-concepts">Core Concepts</h2>
        
        <h3>Retry Amplification</h3>
        <p>When services fail, naive retry policies can make things worse. Consider a 3-tier system:</p>
        <ul>
          <li>Tier 3 starts failing 50% of requests</li>
          <li>Tier 2 retries those failures (load doubles)</li>
          <li>Tier 1 retries Tier 2 failures (load doubles again)</li>
          <li>Result: Tier 3 receives <strong>6.6x normal load</strong></li>
        </ul>
        <p>This is called <strong>retry amplification</strong>, and it's why Polite Retry exists.</p>

        <h3>Retry Budget</h3>
        <p>A retry budget limits the total retry overhead. If your budget is 20%, you can only have 20 retries for every 100 original requests, preventing amplification.</p>

        <h3>Backpressure</h3>
        <p>Downstream services can signal when they're overloaded. Polite Retry respects these signals and stops retrying when a service is struggling.</p>

        <h2 id="basic-retry">Basic Retry</h2>
        <p>Use <code>retry()</code> for simple scenarios with exponential backoff:</p>
        <div class="code-example">
          <pre><code class="language-typescript">import { retry } from 'polite-retry';

const result = await retry(
  async () => fetchData(),
  {
    maxRetries: 3,           // Try up to 4 times total
    initialDelayMs: 100,     // Start with 100ms delay
    maxDelayMs: 10000,       // Cap at 10 seconds
    backoffMultiplier: 2,    // Double delay each time
    jitter: 'full',          // Add randomization
    timeoutMs: 5000,         // 5s timeout per attempt
    retryIf: (error) => {
      // Only retry server errors, not client errors
      return !error.message.includes('4');
    },
    onRetry: (error, attempt, delay) => {
      console.log(`Retry ${attempt} in ${delay}ms: ${error.message}`);
    }
  }
);</code></pre>
        </div>

        <h2 id="circuit-breaker">Circuit Breaker Pattern</h2>
        <p>The circuit breaker stops all requests when a service is down, giving it time to recover:</p>
        <div class="code-example">
          <pre><code class="language-typescript">import { retryWithCircuitBreaker, CircuitBreaker } from 'polite-retry';

// Create one circuit breaker per downstream service
const paymentBreaker = new CircuitBreaker({
  failureThreshold: 0.5,   // Open after 50% failures
  windowSize: 10,          // Look at last 10 requests
  resetTimeoutMs: 30000,   // Test again after 30s
  onStateChange: (state) => {
    console.log(`Circuit is now: ${state}`);
  }
});

// Use for all requests to this service
const result = await retryWithCircuitBreaker(
  async () => chargePayment(amount),
  paymentBreaker,
  { maxRetries: 3 }
);</code></pre>
        </div>

        <div class="alert alert-info">
          <strong>Circuit States:</strong>
          <ul>
            <li><strong>Closed:</strong> Normal operation, requests pass through</li>
            <li><strong>Open:</strong> Service is down, requests fail immediately</li>
            <li><strong>Half-Open:</strong> Testing if service recovered</li>
          </ul>
        </div>

        <h2 id="adaptive-budget">Adaptive Retry Budgeting</h2>
        <p>This is the recommended approach for production. ARB dynamically limits retries based on observed failure rates:</p>
        <div class="code-example">
          <pre><code class="language-typescript">import { retryWithBudget, AdaptiveRetryBudget } from 'polite-retry';

// Create one budget per downstream service
const apiBudget = new AdaptiveRetryBudget({
  initialBudget: 0.2,        // Allow 20% retry overhead
  highFailureThreshold: 0.3, // Reduce budget when >30% failing
  lowFailureThreshold: 0.05, // Restore budget when <5% failing
  adjustmentIntervalMs: 1000,
  onBudgetChange: (budget, failureRate) => {
    metrics.gauge('retry_budget', budget);
    metrics.gauge('failure_rate', failureRate);
  }
});

// Use for all requests to this service
const data = await retryWithBudget(
  async () => fetchFromAPI(),
  apiBudget,
  { maxRetries: 3, jitter: 'full' }
);

// Clean up when shutting down
process.on('SIGTERM', () => {
  apiBudget.dispose();
});</code></pre>
        </div>

        <h3>How ARB Works</h3>
        <table class="param-table">
          <tr>
            <th>Situation</th>
            <th>Budget Action</th>
          </tr>
          <tr>
            <td>Failure rate &lt; 5%</td>
            <td>Increase budget (up to initial)</td>
          </tr>
          <tr>
            <td>Failure rate 5-30%</td>
            <td>Keep budget stable</td>
          </tr>
          <tr>
            <td>Failure rate &gt; 30%</td>
            <td>Decrease budget by 50%</td>
          </tr>
          <tr>
            <td>Backpressure signal</td>
            <td>Stop retries immediately</td>
          </tr>
        </table>

        <h2 id="combined">Combined Protection</h2>
        <p>For critical systems, combine both circuit breaker and adaptive budget:</p>
        <div class="code-example">
          <pre><code class="language-typescript">import { 
  retryWithProtection, 
  CircuitBreaker, 
  AdaptiveRetryBudget 
} from 'polite-retry';

const breaker = new CircuitBreaker({ failureThreshold: 0.5 });
const budget = new AdaptiveRetryBudget({ initialBudget: 0.2 });

const result = await retryWithProtection(
  async () => criticalOperation(),
  { circuitBreaker: breaker, budget },
  { maxRetries: 3, jitter: 'full' }
);</code></pre>
        </div>

        <h2 id="backoff">Backoff Strategies</h2>
        <p>Backoff determines how long to wait between retries:</p>
        <div class="code-example">
          <pre><code class="language-typescript">// Delays: 100ms, 200ms, 400ms, 800ms...
{
  initialDelayMs: 100,
  backoffMultiplier: 2,
  maxDelayMs: 30000  // Cap at 30 seconds
}</code></pre>
        </div>

        <h2 id="jitter">Jitter Explained</h2>
        <p>Jitter adds randomness to prevent synchronized retries:</p>
        <table class="param-table">
          <tr>
            <th>Strategy</th>
            <th>Formula</th>
            <th>Best For</th>
          </tr>
          <tr>
            <td><code>'none'</code></td>
            <td>delay (no change)</td>
            <td>Testing only</td>
          </tr>
          <tr>
            <td><code>'full'</code></td>
            <td>random(0, delay)</td>
            <td>General use (recommended)</td>
          </tr>
          <tr>
            <td><code>'equal'</code></td>
            <td>delay/2 + random(0, delay/2)</td>
            <td>When minimum delay matters</td>
          </tr>
          <tr>
            <td><code>'decorrelated'</code></td>
            <td>random(base, prev * 3)</td>
            <td>Correlated sequences</td>
          </tr>
        </table>

        <div class="alert alert-warning">
          <strong>Warning:</strong> Never use <code>jitter: 'none'</code> in production. It causes synchronized retry storms.
        </div>

        <h2 id="backpressure">Backpressure Signaling</h2>
        <p>Allow downstream services to signal when they're overloaded:</p>

        <h3>Server Side (Express)</h3>
        <div class="code-example">
          <pre><code class="language-typescript">import { RequestCounter, createBackpressureMiddleware } from 'polite-retry';

const counter = new RequestCounter();

// Track active requests
app.use(counter.middleware());

// Add backpressure headers to responses
app.use(createBackpressureMiddleware({
  getLoadLevel: () => counter.getCount() / 100,
  overloadThreshold: 0.8,
}));</code></pre>
        </div>

        <h3>Client Side</h3>
        <div class="code-example">
          <pre><code class="language-typescript">import { BackpressureManager, AdaptiveRetryBudget } from 'polite-retry';

const backpressure = new BackpressureManager();

const budget = new AdaptiveRetryBudget({
  checkBackpressure: () => backpressure.isOverloaded('api-service'),
});

// Record backpressure from responses
const response = await fetch('/api/data');
backpressure.recordFromHeaders('api-service', response.headers);</code></pre>
        </div>

        <h2 id="metrics">Metrics and Monitoring</h2>
        <div class="code-example">
          <pre><code class="language-typescript">const budget = new AdaptiveRetryBudget({
  onBudgetChange: (budget, failureRate) => {
    // Send to your metrics system
    statsd.gauge('retry.budget', budget);
    statsd.gauge('retry.failure_rate', failureRate);
  }
});

// Periodically export metrics
setInterval(() => {
  const m = budget.getMetrics();
  statsd.gauge('retry.amplification_factor', m.retryAmplificationFactor);
  statsd.counter('retry.total_requests', m.totalRequests);
  statsd.counter('retry.total_retries', m.totalRetries);
}, 10000);</code></pre>
        </div>

        <h2 id="dos-donts">Dos and Don'ts</h2>
        
        <h3>‚úÖ Do</h3>
        <ul>
          <li><strong>Use jitter:</strong> Always use <code>jitter: 'full'</code></li>
          <li><strong>Share budgets:</strong> One budget per downstream service</li>
          <li><strong>Limit retries:</strong> 3 retries is usually enough</li>
          <li><strong>Set timeouts:</strong> Don't wait forever for a response</li>
          <li><strong>Be selective:</strong> Only retry transient errors</li>
          <li><strong>Monitor:</strong> Track retry rates and amplification</li>
        </ul>

        <h3>‚ùå Don't</h3>
        <ul>
          <li><strong>Immediate retries:</strong> Always use backoff</li>
          <li><strong>Retry everything:</strong> Don't retry 4xx errors</li>
          <li><strong>Infinite retries:</strong> Cap at 3-5 attempts</li>
          <li><strong>Ignore backpressure:</strong> Respect overload signals</li>
          <li><strong>Create budget per request:</strong> Share across requests</li>
        </ul>

        <h2 id="production">Production Tips</h2>
        <ol>
          <li><strong>Start conservative:</strong> Begin with <code>initialBudget: 0.1</code> (10%)</li>
          <li><strong>Monitor amplification:</strong> Alert if RAF > 1.5</li>
          <li><strong>Implement backpressure:</strong> Add headers to your services</li>
          <li><strong>Clean up:</strong> Call <code>budget.dispose()</code> on shutdown</li>
          <li><strong>Test failure scenarios:</strong> Use chaos engineering</li>
        </ol>

        <div class="cta-buttons">
          <a href="api.html" class="btn btn-primary">API Reference</a>
          <a href="examples.html" class="btn btn-secondary">See Examples</a>
        </div>
      </div>
    </div>
  </main>

  <footer class="footer">
    <div class="container">
      <p>Created by <a href="https://github.com/darkrishabh">Rishabh Mehan</a> ‚Ä¢ MIT License</p>
    </div>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</body>
</html>
